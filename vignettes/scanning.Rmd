---
title: "Scanning sequences and exploring matches"
author: 
- name: Pierre-Luc Germain
  affiliation: D-HEST Institute for Neuroscience, ETH & Lab of Statistical Bioinformatics, UZH
- name: Michael Soutschek
  affiliation: Lab of Systems Neuroscience, D-HEST Institute for Neuroscience, ETH
- name: Fridolin Gross
  affiliation: Lab of Systems Neuroscience, D-HEST Institute for Neuroscience, ETH
package: scanMiR
output:
  BiocStyle::html_document
abstract: |
  This vignettes explores scanMiR's scanning functions.
vignette: |
  %\VignetteIndexEntry{3_scanning}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE}
library(BiocStyle)
# only for testing
devtools::load_all("/mnt/schratt/miRNA_KD/fg_test/scanMiR")
# library(scanMiR)
```

# Basic Scan
The main function used for determining matches of miRNA seeds in a given set of sequences is `findSeedMatches`. It accepts a set of DNA sequences either as a character vector or as a [DNAStringSet](https://bioconductor.org/packages/release/bioc/html/Biostrings.html). Seeds can be given either as a character vector or as a `KdModelList`. The following example illustrates the basic usage:

```{r}
# generate a set of mock sequences and seeds
seqs <- vapply(1:10,
               FUN=function(x) {
                 paste(sample(c("A", "C", "G", "T"), 1000, replace=TRUE),
                       collapse="")},
               character(1))
names(seqs) <- paste0("seq",1:length(seqs))

seeds <- c("AAACCAC", "AAACCUU")

# run the scan
matches <- findSeedMatches(seqs, seeds, verbose = FALSE)
```

By default, a [GRanges](https://bioconductor.org/packages/release/bioc/html/GenomicRanges.html) object is returned. Apart from the position of the matches, it provides information on the match type. Setting `ret = "data.frame"` returns the same information as a data.frame. The scan can be restricted to canonical sites using `onlyCanonical = TRUE`.

# Further Options

## ORF length
If the transcript sequences are provided as a `DNAStringSet`, one may specify the length of the open reading frame region of the transcripts in order to distinguish between matches in the ORF and 3'UTR regions.
```{r}
seqs <- DNAStringSet(seqs)
mcols(seqs)$ORF.length <- sample(500:800, length(seqs))
```

## Shadow and Overlapping Matches
The `shadow` argument can be used to take into account the observation that sites within the first ~15 nucleotides of the 3'UTR show poor efficiency ([Grimson et al. 2007](https://www.sciencedirect.com/science/article/pii/S1097276507004078)). `findSeedMatches` will treat matches within the first `shadow` positions of the UTR in the same way as matches in the ORF region. If no information on ORF lengths is provided, it will simply ignore the first `shadow` positions. The default setting is `shadow = 0L`.

The parameter `minDist` can be used to specify the minimum distance between matches of the
same miRNA (default 1). If there are multiple matches within `minDist`, only the highest affinity match will be considered.

## Site Affinities
If the seeds are given in the form of a `KdModelList`, `findSeedMatches` also returns the predicted affinity value for each match. The `log_kd` column contains log(KD) values multiplied by 1000, where KD is the predicted dissociation constant of miRNA:mRNA binding at the respective site. In addition, a column `p3.score` is returned, which carries information on 3p alignment.

```{r}
# load KdModel
data(SampleKdModel)
kd_seeds <- KdModelList(list(SampleKdModel))
kd_matches <- findSeedMatches(seqs, kd_seeds, verbose = F)
```


## Aggregation on the fly
With `ret = "aggregated"` one obtains a data.frame that contains the predicted repression for each sequence-seed-pair aggregated over all matches along with information about the types and number of matches. For further details on how the repression value is determined, see the vignette on [aggregation](aggregation.html).

## Parallel Processing
To deal with large amounts of sequences and/or seeds, `findSeedMatches` supports multithreading using the `r Biocpkg("BiocParallel")` package. This can be activated by passing `BP = MulticoreParam(ncores)`. In addition, the number of seeds that is processed simultaneously can be restricted using the parameter `n_seeds` in order to avoid memory issues.

# Session info {.unnumbered}

```{r sessionInfo, echo=FALSE}
sessionInfo()
```
